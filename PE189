// SOLVES PROJECT EULER 189 TRI-COLORING A TRIANGULAR GRID
// https://projecteuler.net/problem=189

//  2.3 SECONDS FOR 7 ROWS (49 NODE GRAPH)
//  5.7 MINUTES FOR 8 ROWS (64 NODE GRAPH)

#include <iostream>
#include <algorithm>
#include <vector>
#include <stack>
#include <unordered_map>
#include <cassert>
#include <limits>
using namespace std;

template < typename T >
class  Polynomial
{
  public:
    using  i64 = int64_t;
    using  P   = Polynomial<T>;

    vector<T>  a;

  public:
    constexpr Polynomial( size_t sz = 0 )  { a.resize( sz, 0 ); }
    constexpr Polynomial( const initializer_list<T>  v )  { a = v; }
    constexpr Polynomial( const vector<T>  &v )  { a = v; }
    constexpr Polynomial( size_t sz, T val )  { a.resize( sz, val ); }
    constexpr size_t  size() const { return a.size(); }
    void  resize( size_t sz, T m = 0 )  { (*this).a.resize( sz, m ); }

    constexpr P  operator - ( const P &a ) const { return  P(*this) -= a; }
    constexpr P  operator + ( const P &a ) const { return  P(*this) += a; }
    constexpr P  operator * ( const i64 a )  const { return  P(*this) *= a; }
    constexpr P  operator * ( const P &a ) const { return  P(*this) *= a; }

    P  &operator += ( const P &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] += r.a[i];
        return  *this;
    }
    P  &operator -= ( const P &r )  {
        this->resize( max( this->size(), r.size() ) );
        for( size_t i=0 ; i<r.size() ; ++i )  this->a[i] -= r.a[i];
        return  *this;
    }
    P  &operator *= ( const i64 v )  {
        for( size_t i=0 ; i<this->size() ; ++i )  this->a[i] *= v;
        return  *this;
    }
    P  &operator *= ( const P &r )  {
        this->convolution_inplace( r );
        return  *this;
    }
    P pow( int b )  {
        P  res = { 1 };
        P  a   = *this;
        while( b > 0 )  {
            if( b & 1 )    res = a * res;
            b >>= 1;
            if( b > 0 )    a   = a * a;
        }
        return  res;
    }
    T  evaluate( i64 x )  {
        T  ans = 0;
        T  powx = 1;
        for( auto &v : a )  {
            ans += v*powx;
            powx *= x;
       }
       return  ans;
    }
    friend std::ostream &operator << ( std::ostream &os, const P &p )  {
        for( auto &v : p.a )   os << v << " ";
        return  os;
    }
    friend istream& operator >> ( istream& is, P &p )  {
        for( auto &v : p.a )  { i64 w;  is >> w;  v = w; }   return  is;
    }

  private:
    T  &operator [] ( size_t  x )  {
        assert( x < this->a.size() );
        return  a[x];
    }
    constexpr T  &operator [] ( size_t  x ) const {
        assert( x < this->a.size() );
        return  a[x];
    }
    P  convolution_brute( P &a, P &b ) const  {
        size_t  n = a.size(),  m = b.size();
        P  ans( n + m - 1 );
        if( n < m )
            for( size_t j=0 ; j<m ; ++j )
                for( size_t i=0 ; i<n ; ++i )   ans[i+j] += a[i]*b[j];
        else
            for( size_t i=0 ; i<n ; ++i )
                for( size_t j=0 ; j<m ; ++j )   ans[i+j] += a[i]*b[j];
        return ans;
    }

    P&  convolution_inplace( P b )  {
        if( this->size() == 0  ||  b.size() == 0 )  {
            this->a.clear();  return  *this; }
        return  *this = convolution_brute( *this, b );
    }
};

/* =======================================================================*/

using  Poly = Polynomial< int64_t >;
using  mint = int64_t;
using  i32  = int32_t;     using  i64 = int64_t;
using  u32  = uint32_t;    using  u64 = uint64_t;
using  pr   = pair<u32, u32>;

mint  pow( mint a, u64 i )  {
    mint  r = a,  res = 1;
    while( i )  {
        if( i & 1 )   res = res * r;
        r = r * r;   i >>= 1;
    }
    return  res;
}

// WILL USE AN UNORDERED MAP TO MEMOIZE GRAPH/POLYNOMIAL PAIRS SO NEED HASH
// FOR G, I.E.  vector<u64>
class  Myhash  {
  private:
    static inline uint64_t  ror64( uint64_t v, int r )  {
        return  ( v >> r ) | ( v << ( 64 - r ) );
    }

    uint64_t  hashu64( uint64_t v ) const  {
        v ^= ror64( v, 25 ) ^ ror64( v, 50 );
        v *= 0xA24BAED4963EE407UL;
        v ^= ror64( v, 24 ) ^ ror64( v, 49 );
        v *= 0x9FB21C651E98DF25UL;
        return  v ^ v >> 28;
    }

    template <typename T, typename S>
    typename std::enable_if< std::is_unsigned<T>::value, T >::type
    constexpr  rotl( const T n, const S i ) const  {
        const T  m = ( std::numeric_limits<T>::digits - 1 );
        const T  c = i & m;
        return  ( n << c ) | ( n >> ( (T(0) - c ) & m ) );
    }

  public:
    size_t  operator()( const vector<u64> &vec ) const  {
        size_t  ret = 0;
        for( auto &i : vec )
            ret = rotl( ret, 11 ) ^ hashu64( i );
        return  ret;
    }
};

unordered_map< vector<u64>, mint, Myhash >  memo;

class  Graph  {
  public:
    vector<u64>  g;

    // CONSTRUCTORS
    Graph() {};
    Graph( const vector<u64> &v ) { g = v; }

    Graph  contractEdge( const pr &edge )  {
        Graph  G( *this );
        const auto  [u, v] = edge;
        G.g[u] |= G.g[v];                                 // ASSIGN NBRS OF v TO u
        for( auto &e : G.g )   e |= ( e >> v & 1 ) << u;  // IF v WAS NBR, ADD u
        G.g[u] &= ~( 1ULL << u );                         // u IS NOT NBR OF ITSELF
        for( auto &e : G.g )  {                           // DELETE COLUMN v
            e = ( e &  ( ( 1ULL << v ) - 1 ) )  |
                ( e & ~( ( 1ULL << ( v + 1 ) ) - 1 ) ) >> 1;
        }
        G.g.erase( G.g.begin() + v );                    // DELETE ROW v
        return  G;
    }

    bool  findBridge( pr &edge )  {
        const u32  n = g.size();
        u32  best    = 0;
        u64  visited = 0ULL;
        edge         = { 0, 0 };
        vector<u32>  tin( n, 0 );
        vector<u32>  low( n, 0 );

        for( u32 i=0 ; i<n ; ++i )
            if( !( visited >> i & 1 ) )
                bridgeDFS( tin, low, visited, best, edge, i );
        return  ( edge != pr( { 0, 0 } ) ) ? true : false;
    }

    bool  isComplete()  {
        const int  n = (int)g.size() - 1;
        for( auto e : g )
            if( __builtin_popcountll( e ) != n )   return false;
        return  true;
    }

    bool  isLoop()  {   // ASSUMES G IS CONNECTED AND NOT CHORDAL
        if( g.size() < 4 )   return  false;
        for( u64 e : g )
            if( __builtin_popcountll( e ) != 2 )   return  false;
        return  true;
    }

    Graph  deleteEdge( const pr &edge )  {
        const auto [u, v] = edge;
        Graph  K( *this );
        K.g[u] &= ~( 1ULL << v );
        K.g[v] &= ~( 1ULL << u );
        return  K;
    }

    Graph  addEdge( const pr &edge )  {
        const auto [u, v] = edge;
        Graph  K( *this );
        K.g[u] |= ( 1ULL << v );
        K.g[v] |= ( 1ULL << u );
        return  K;
    }

    pr  chooseEdge()  {
        pr   edge = { 0, 0 };
        int  best = 0;
        const u32  n = g.size();
        for( u32 u=0 ; u<n ; ++u )  {
            auto  p = __builtin_popcountll( g[u] )/3;
            for( u32 v=u+1 ; v<n ; ++v )  {
                if( ( g[u] >> v & 1 )  &&  ( best == 0  ||
                    p + __builtin_popcountll( g[v] ) <= best ) )  {
                    best = p + __builtin_popcountll( g[v] );
                    edge = { u, v };
                }
            }
        }
        return  edge;
    }

    pr  newEdge()  {
        pr   edge = { 0, 0 };
        int  best = 0;
        const u32  n = g.size();
        for( u32 u=0 ; u<n ; ++u )  {
            auto  p = __builtin_popcountll( g[u] );
            for( u32 v=u+1 ; v<n ; ++v )  {
                if( !( g[u] >> v & 1 )  &&
                    p + __builtin_popcountll( g[v] ) >= best )  {
                     best = p + __builtin_popcountll( g[v] );
                     edge = { u, v };
                }
            }
        }
        return  edge;
    }

    int  countEdges2x()  {
        int  ret = 0;
        for( auto &e : g )   ret += __builtin_popcountll( e );
        return  ret;
    }

    double  density()  {
        return  double( countEdges2x() ) / double( g.size() * ( g.size() - 1 ) );
    }

    Graph  extractNodes( const vector<u32> &nodes )  {
        const size_t  n = nodes.size();
        Graph  G( *this );
        for( size_t i=0 ; i<n ; ++i )   G.g[i] = G.g[nodes[i]];
        G.g.resize( n );

        for( auto &e : G.g )  {
            for( size_t j=0 ; j<n ; ++j )
                e = ( e & ~( 1ULL << j ) )  |  ( e >> nodes[j] & 1 ) << j;
            e &= ( 1ULL << n ) - 1;
        }
        return  G;
    }

    // LEXICOGRAPHIC BFS
    vector<u32>  chordalOrdering()  {
        const u32  n = g.size();
        vector<u64>  currentLabel( n, 0ULL );
        stack< pair<u64, u32> >  stk;
        u64  visited = 0ULL;

        for( u32 i=0 ; i<n ; ++i )   stk.emplace( 0ULL, i );

        vector<u32>  ordr;
        for( u32 i=0 ; i<n ; ++i )  {
            u32  u;
            u64  label;
            do  {
                tie( label, u ) = stk.top();
                stk.pop();
            }  while( ( visited >> u & 1 )  ||  label != currentLabel[u] );

            visited |= 1ULL << u;
            ordr.push_back( u );

            for( u32 j=0 ; j<n ; ++j )
                if( ( g[i] >> j & 1 )  &&  !( visited >> j & 1 ) )
                    stk.emplace( currentLabel[j] |= 1ULL << i, j );
        }
        return  ordr;
    }

    mint  checkIfChordal( mint K, bool &ok )  {
        // https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search
        ok = true;
        vector<u32>  ordering = chordalOrdering();
        u64  visited = 0;
        vector<u32>  tally( g.size(), 0 );

        for( u32 u : ordering )  {
            u64  neighbors = g[u] & visited;
            u32  cnt = 0;

            while( neighbors > 0ULL )  {
                const u32  v = __builtin_ctzll( neighbors );
                neighbors -= 1ULL << v;

                if( ( g[v] & neighbors ) != neighbors )  {
                    // G NOT CHORDAL
                    ok = false;
                    return  0;
                }
                ++cnt;
            }
            visited |= 1ULL << u;
            ++tally[cnt];
        }

        // G IS CHORDAL
        mint  chromPoly = 1;
        for( i32 i=0 ; i<(i32)g.size() ; ++i )
            if( tally[i] )   chromPoly *= pow( mint( K - i ), tally[i] );
        return  chromPoly;
    }

    // FIND CONNECTED COMPONENTS OF G
    vector<vector<u32>>  components()  {
        const u32  n = g.size();
        u64  visited = 0ULL;
        vector<vector<u32>>  comps;

        for( u32 i=0 ; i<n ; ++i )  {
            if( visited >> i & 1 )   continue;
            stack<u32>  stk;
            stk.push( i );
            visited |= 1ULL << i;
            vector<u32>  component;

            while( stk.size() )  {
                u32  u = stk.top();
                stk.pop();
                component.push_back( u );
                for( u32 v=0 ; v<n ; ++v )
                    if( ( g[u] >> v & 1 )  &&  !( visited >> v & 1 ) )  {
                        visited |= 1ULL << v;
                        stk.push( v );
                    }
            }
            sort( component.begin(), component.end() );
            comps.push_back( component );
        }
        return  comps;
    }

    mint  chromaticPolynomial( mint  K )  {
        // FIND CONNECTED COMPONENTS OF G
        vector< vector<u32> >  comps = components();

        // PROCESS EACH CONNECTED COMPONENT SEPARATELY
        if( comps.size() > 1 )  {
            mint  cp = 1;
            for( auto &cmp : comps )  {
                if( cmp.size() == 0 );
                else if( cmp.size() == 1 )   cp *= K;
                else if( cmp.size() == 2 )   cp *= K * K - K;
                else  cp *= extractNodes( cmp ).chromaticPolyConnected( K );
            }
            return  cp;
        }
        return  chromaticPolyConnected( K );
    }

  private:
    void  bridgeDFS( vector<u32> &tin, vector<u32> &low, u64 &visited, u32 &best,
                     pr &edge, u32 u, i32 p = -1 )  {
        static u32  timer = 0;
        const u64  gu  = g[u];
        const u32  pcu = __builtin_popcountll( gu );
        bool  parentSkipped = false;
        tin[u] = low[u] = timer++;
        visited |= ( 1ULL << u );

        for( u32 v=0 ; v<(u32)g.size() ; ++v )  {
            if( gu >> v & 1 )  {
                if( (i32)v == p  &&  !parentSkipped )  {
                    parentSkipped = true;
                    continue;
                }
                if( visited >> v & 1 )  {
                    low[u] = min( low[u], tin[v] );
                }  else  {
                    bridgeDFS( tin, low, visited, best, edge, v, u );
                    low[u] = min( low[u], low[v] );
                    if( low[v] > tin[u]  &&  pcu + __builtin_popcountll( g[v] ) > best ) {
                        best = pcu + __builtin_popcountll( g[v] );
                        edge = { u, v };
                    }
                }
            }
        }
    }

    mint  chromaticPolyConnected( mint K, bool checkBridges = true )  {
        // G IS ASSUMED CONNECTED.  CONNECTIVITY IS MAINTAINED.
        const i32  n = g.size();
        if( n == 0 )   return  1;
        if( n == 1 )   return  K;
        if( n == 2 )   return  K*K - K;
        if( n == 3 )  {
            if( isComplete() )    return  K*( K*K - K - K - K + 2 );
            else                  return  K*( K*K - K - K + 1 );
        }

        if( memo.find( g ) != memo.end() )   return  memo[g];

        // CHECK FOR COMPLETE GRAPH
        if( isComplete() )  {
            mint  chromPoly = 1;
            for( i32 i=0 ; i<n ; ++i )  chromPoly *= ( K - i );
            return  chromPoly;
        }

        // CHECK FOR BRIDGES
        if( checkBridges )  {
            pr  edge;
            if( findBridge( edge ) )
                return  memo[g] = contractEdge( edge ).chromaticPolyConnected( K ) * ( K - 1 );
        }

        // CHECK IF G IS CHORDAL
        bool  ok = true;
        mint  chordalPoly = checkIfChordal( K, ok );
        if( ok )   return  memo[g] = chordalPoly;

        // CHECK IF LOOP
        if( isLoop() )  {
            mint  basic     =  K - 1;
            mint  chromPoly = pow( basic, n );
            if( g.size() & 1 )    chromPoly -= basic;
            else                  chromPoly += basic;
            return  chromPoly;
        }

        // NO JOY.  PERFORM DELETION/CONTRACTION.
        if( density() <= .6 ) {
            // LOW DENSITY
            pr  edge = chooseEdge();
            return  memo[g] = deleteEdge( edge ).chromaticPolyConnected( K ) -
                              contractEdge( edge ).chromaticPolyConnected( K );
        }

        // IF HIGH DENSITY
        pr  edge = newEdge();
        Graph  H = addEdge( edge );
        return  memo[g] = H.chromaticPolyConnected( K, false ) +
                          H.contractEdge( edge ).chromaticPolyConnected( K );
    }
};

pair<u32, vector<u64>>  readData()  {
    // REQUIRES NODES TO BE LABELED  0 through ( n - 1 )
    u32  n, m;
    cin >> n >> m;

    vector<u64>  G( n, 0 );

    for( u32 i=0, u, v ; i<m ; ++i )  {
        cin >> u >> v;  --u;  --v;
        if( u == v )   return  make_pair( n, G );

        G[u] |= 1ULL << v;
        G[v] |= 1ULL << u;
    }
    return  make_pair( 0, G );
}

Graph  getG( int n )  {
    vector<u64>  G( n*n, 0 );
    Graph  g( G );

    for( int N=0 ; N<n*n ; ++N )  {
        for( int j= N*N ; ; ++j )  {
            int  i = j + 1;
            if( i >= (N + 1)*(N + 1)  ||  i >= n*n )   break;
            g = g.addEdge( make_pair( i, j ) );
            g = g.addEdge( make_pair( j, i ) );
        }
    }

    for( int N=0 ; N<n*n ; ++N )  {
        for( int j= N*N ; ; j+=2 )  {
            int  i = j + ((N + 1) * 2);
            if( j >= (N + 1)*(N + 1)  ||  i >= n*n )   break;
            g = g.addEdge( make_pair( i, j ) );
            g = g.addEdge( make_pair( j, i ) );
        }
    }
    return  g;
}

//    ======== 128 BIT INTEGER CODE BEGIN ========
typedef __int128_t  _LLI;

string toString( _LLI value )  {
    string  output;
    while( output.empty()  ||  value > 0 )  {
        output = (char)( value %10 + '0' ) + output;
        value /= 10;
    }
    return output;
}
istream& operator >> ( istream &stream, _LLI &v )  {
    string  s;
    stream >> s;
    bool  neg = false;
    if( s[0] == '-' )    { s.erase( 0, 1 );   neg = true; }
    int len = s.length();    v = 0;
    for( int32_t i=0 ; i<len ; ++i )    v = v*10 + s[i] - '0';
    if( neg )    v = -v;
    return stream;
}
ostream& operator << ( ostream &stream, _LLI v )  {
    if( v == 0 )    stream << "0";
    else  {
        if( v < 0 )  { stream << "-";    v = -v; }
        stream << toString( v );
    }
    return stream;
}
//    ======== 128 BIT INTEGER CODE END ========


int  main()  {
    ios::sync_with_stdio( 0 );
    cin.tie( 0 );

    Graph  G = getG( 7 );

    auto  ans = G.chromaticPolynomial( 3 );
    cout << ans << '\n';

    return 0;
}
